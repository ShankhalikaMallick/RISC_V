
# 3. Sequential Logic Optimization

In this subdivision, I focused on **sequential logic optimization**.  
I analyzed and synthesized several **D flip-flop (dff)** based modules with constant inputs, observing how the synthesis tool optimizes redundant logic.

---

##  What I Learned

- Sequential constant propagation is very effective in removing redundant flip-flops when outputs are constant.  
- Synthesis tools can optimize DFF-based modules into simpler logic (like wires) if possible, saving area.  
- Observing synthesis statistics and graphical representation helps me understand how the tool interprets my RTL.  
- Understanding sequential optimization helps me write **more efficient RTL** for state machines and memory elements.  

---

##  Files Analyzed
 
1. **dff_const1**  
2. **dff_const2**  
3. **dff_const3**  

I performed **Verilog code analysis**, **synthesis**, and studied the **graphical representation** of each design.  

---

##  dff_const1

- **Observation:** Standard DFF; output depends on input.  
- Synthesizer prints DFFs correctly.  

- **Key Learnings:**  
  - Confirms correct mapping of flip-flops.  
  - Useful for sequential logic verification.  

- **Screenshot: Verilog Module**  
<img width="945" height="179" alt="image" src="https://github.com/user-attachments/assets/65729a81-0329-436c-9986-d78e4d8c070f" />
 
---

- **Screenshot: Synthesis Statistics**
  
<img width="1173" height="607" alt="image" src="https://github.com/user-attachments/assets/a4b4c6a5-ac6e-4a55-8cc0-dbcb6e05e4ac" />
 

  - Here there is no possiblity of optimizing the design hence 1 DFF is used.

  ---

- **Screenshot: Graphical Representation**  

<img width="1280" height="800" alt="image" src="https://github.com/user-attachments/assets/92b5ffef-6e0f-4e13-bf0f-0df43ce406ee" />


---

##  dff_const2

- **Observation:** Output is **always 1** regardless of inputs or reset.  
- Synthesizer optimized logic into a **wire**, no DFFs printed.  

- **Key Learnings:**  
  - Sequential constant propagation removes redundant flip-flops.  
  - Recognizing constant outputs helps simplify the design.  

- **Screenshot: Verilog Module**  

<img width="945" height="179" alt="image" src="https://github.com/user-attachments/assets/6aa30906-8f18-492d-99fa-c40f6af943c5" />
  

  ---

- **Screenshot: Synthesis Statistics**  

<img width="446" height="303" alt="image" src="https://github.com/user-attachments/assets/9841cc1d-62c0-4d18-84da-0079f8cb5a9a" />


  - Here the DFF is always logic 1 **independent of input and reset** . Hence DFF is optimized into a logic 1 wire.

  --- 

- **Screenshot: Graphical Representation**  

<img width="1280" height="800" alt="image" src="https://github.com/user-attachments/assets/e2009392-c9ab-4b35-8c4f-9a95701b8e97" />


---

##  dff_const3

- **Observation:** Similar to const2; constant output optimized.  
- Synthesizer reduces redundant flip-flops.  

- **Key Learnings:**  
  - Constant outputs in sequential circuits can be optimized to **wires**.  
  - Helps save area and reduce unnecessary hardware.  

- **Screenshot: Verilog Module**  
<img width="534" height="348" alt="image" src="https://github.com/user-attachments/assets/b7b4f1c7-a1f9-49bb-91c8-83d60d8be8f7" />
 

  - The design can't be optimized. Hence the design requires 2 Flip Flops.
  ---

- **Screenshot: Synthesis Statistics**  
<img width="612" height="407" alt="image" src="https://github.com/user-attachments/assets/c95a041d-ab4b-4a32-a270-04ba058cc2f4" />


   
  - Hence the printing statistics proved that the design can't be optimized.
  - It printed 2 Flip Flops.

  ---

- **Screenshot: Graphical Representation**  

<img width="612" height="275" alt="image" src="https://github.com/user-attachments/assets/e7c0cffb-929c-46b0-8580-5a7f18b1215a" />


---

##  Lab Experiments

###  Lab 1 – dff_const4

- Performed analysis and synthesis for sequential optimization.  
- Redundant flip-flops removed wherever possible.  

- **Screenshot: Verilog Module**  
<img width="514" height="328" alt="image" src="https://github.com/user-attachments/assets/efbc27b9-bf14-4fe9-9b96-7841de66e182" />


  - In this module, irrespective of the clock and Reset the output `q` and `q1` will stay at logic 1.
  - Hence we don't need any flip flops to store. Just logic 1 wire is enough.

---

- **Screenshot: Synthesis Statistics**  
<img width="612" height="380" alt="image" src="https://github.com/user-attachments/assets/31432684-ac1b-4a99-83db-d0b5b08a2bec" />



  - The synthesis stats proved no hardware (FF) is needed. 
  - Hence the design was optimized by the synthesizer (Yosys).

---

- **Screenshot: Graphical Representation**  

<img width="612" height="408" alt="image" src="https://github.com/user-attachments/assets/591f409e-037a-4e60-9b09-4737d2aaa941" />

---

###  Lab 2 – dff_const5

- Similar analysis and optimization as const4.  

- **Screenshot: Verilog Module**  
<img width="534" height="348" alt="image" src="https://github.com/user-attachments/assets/4abb654d-2b05-4732-ad6c-bf4c3ddb49e8" />


  - From the module, it is clearly seen that the design can't be optimized.
  - when the reset is applied, both the outputs `q1` and `q` becomes 0. 
  - If reset is 0 , both the outputs `q1` and `q` becomes 1.
  - So we need 2 flip flops to store the output.

- **Screenshot: Synthesis Statistics**  
<img width="612" height="278" alt="image" src="https://github.com/user-attachments/assets/f74753e4-63ac-4aa2-9da2-d23edff16103" />


  - Yes, our synthesizer also proved that 2 flops is enough for this design.
  - Hence, no optimizations were made.  

  ---

- **Screenshot: Graphical Representation**  
<img width="612" height="348" alt="image" src="https://github.com/user-attachments/assets/2199ba29-ba0e-4e6a-83c2-425de9ab70d0" />



---
